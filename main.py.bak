from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
import jwt
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv
import bcrypt
from pymongo import MongoClient
from bson import ObjectId
from models.messages import Message, encrypt_message, decrypt_message

# Load environment variables
load_dotenv()

# Initialize FastAPI app
app = FastAPI()

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# MongoDB connection
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
client = MongoClient(MONGO_URI)
db = client.whatsapp_db
users_collection = db.users
messages_collection = db.messages

# JWT Configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")
ALGORITHM = "HS256"
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class UserSignup(BaseModel):
    username: str
    email: str
    password: str
    full_name: str

class UserLogin(BaseModel):
    username: str
    password: str

def create_jwt(data: dict, expires_delta: timedelta = timedelta(minutes=30)):
    payload = data.copy()
    expire = datetime.utcnow() + expires_delta
    payload.update({"exp": expire})
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token

def verify_jwt(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.post("/signup")
async def signup(user: UserSignup):
    if users_collection.find_one({"username": user.username}):
        raise HTTPException(status_code=400, detail="Username already registered")
    
    if users_collection.find_one({"email": user.email}):
        raise HTTPException(status_code=400, detail="Email already registered")
    
    hashed_password = bcrypt.hashpw(user.password.encode(), bcrypt.gensalt())
    user_dict = user.dict()
    user_dict["password"] = hashed_password
    user_dict["created_at"] = datetime.utcnow()
    
    result = users_collection.insert_one(user_dict)
    token = create_jwt({"sub": user.username})
    
    return {
        "message": "User created successfully",
        "access_token": token,
        "token_type": "bearer"
    }

@app.post("/token")
async def login(user: UserLogin):
    db_user = users_collection.find_one({"username": user.username})
    if not db_user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    if not bcrypt.checkpw(user.password.encode(), db_user["password"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    token = create_jwt({"sub": user.username})
    return {"access_token": token, "token_type": "bearer"}

@app.get("/protected")
def protected_route(token: str = Depends(oauth2_scheme)):
    payload = verify_jwt(token)
    user = users_collection.find_one(
        {"username": payload["sub"]},
        {"password": 0}  # Exclude password from response
    )
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Convert ObjectId to string for JSON serialization
    user["_id"] = str(user["_id"])
    return {"message": f"Hello {user['full_name']}", "user": user}

@app.get("/users")
async def get_all_users(token: str = Depends(oauth2_scheme)):
    # Verify the user is authenticated
    payload = verify_jwt(token)
    current_user = users_collection.find_one({"username": payload["sub"]})
    
    if not current_user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Fetch all users except the current user
    # Exclude sensitive information like passwords
    users = users_collection.find(
        {"_id": {"$ne": current_user["_id"]}},  # Exclude current user
        {
            "password": 0,  # Exclude password
            "username": 1,
            "email": 1,
            "full_name": 1,
            "_id": 1,
            "created_at": 1
        }
    )
    
    # Convert users to list and format _id to string
    user_list = []
    for user in users:
        user["_id"] = str(user["_id"])
        user_list.append(user)
    
    return user_list

# Initialize messages collection
messages_collection = db.messages

@app.post("/messages/send")
async def send_message(message: Message, token: str = Depends(oauth2_scheme)):
    # Verify the sender
    payload = verify_jwt(token)
    sender = users_collection.find_one({"username": payload["sub"]})
    if not sender:
        raise HTTPException(status_code=404, detail="Sender not found")

    # Verify the receiver exists
    receiver = users_collection.find_one({"_id": ObjectId(message.receiver_id)})
    if not receiver:
        raise HTTPException(status_code=404, detail="Receiver not found")

    # Encrypt the message content
    encrypted_content = encrypt_message(message.content)
    
    # Prepare message document
    message_doc = {
        "sender_id": str(sender["_id"]),
        "receiver_id": message.receiver_id,
        "content": encrypted_content,
        "timestamp": datetime.utcnow(),
        "is_read": False
    }
    
    # Insert the message
    result = messages_collection.insert_one(message_doc)
    
    return {
        "message_id": str(result.inserted_id),
        "timestamp": message_doc["timestamp"]
    }

@app.get("/messages/{chat_partner_id}")
async def get_messages(chat_partner_id: str, token: str = Depends(oauth2_scheme)):
    # Verify the user
    payload = verify_jwt(token)
    current_user = users_collection.find_one({"username": payload["sub"]})
    if not current_user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Get messages between the two users
    messages = messages_collection.find({
        "$or": [
            {
                "sender_id": str(current_user["_id"]),
                "receiver_id": chat_partner_id
            },
            {
                "sender_id": chat_partner_id,
                "receiver_id": str(current_user["_id"])
            }
        ]
    }).sort("timestamp", 1)  # Sort by timestamp ascending
    
    # Decrypt messages and format response
    message_list = []
    for msg in messages:
        decrypted_content = decrypt_message(msg["content"])
        message_list.append({
            "message_id": str(msg["_id"]),
            "sender_id": msg["sender_id"],
            "receiver_id": msg["receiver_id"],
            "content": decrypted_content,
            "timestamp": msg["timestamp"],
            "is_read": msg["is_read"]
        })
    
    return message_listdleware.cors import CORSMiddleware
from pydantic import BaseModel
import jwt
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv
import bcrypt
from pymongo import MongoClient
from bson import ObjectId
from models.messages import Message, encrypt_message, decrypt_message

load_dotenv()

# MongoDB connection
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017")
client = MongoClient(MONGO_URI)
db = client.whatsapp_db
users_collection = db.users

SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key")  # keep this safe
ALGORITHM = "HS256"

app = FastAPI()

# Configure CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allows all origins
    allow_credentials=True,
    allow_methods=["*"],  # Allows all methods
    allow_headers=["*"],  # Allows all headers
)

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

class UserSignup(BaseModel):
    username: str
    email: str
    password: str

class UserLogin(BaseModel):
    email: str
    password: str

def hash_password(password: str) -> bytes:
    return bcrypt.hashpw(password.encode(), bcrypt.gensalt())

def verify_password(plain_password: str, hashed_password: bytes) -> bool:
    return bcrypt.checkpw(plain_password.encode(), hashed_password)

# ðŸ”¹ Generate JWT
def create_jwt(data: dict, expires_delta: timedelta = timedelta(minutes=30)):
    payload = data.copy()
    expire = datetime.utcnow() + expires_delta
    payload.update({"exp": expire})
    token = jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)
    return token

# ðŸ”¹ Decode & verify JWT
def verify_jwt(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")

@app.post("/signup")
async def signup(user: UserSignup):
    # Check if username already exists
    if users_collection.find_one({"username": user.username}):
        raise HTTPException(
            status_code=400,
            detail="Username already registered"
        )
    
    # Check if email already exists
    if users_collection.find_one({"email": user.email}):
        raise HTTPException(
            status_code=400,
            detail="Email already registered"
        )
    
    # Create user document
    user_dict = user.dict()
    user_dict["password"] = hash_password(user.password)
    user_dict["created_at"] = datetime.utcnow()
    
    # Insert into database
    result = users_collection.insert_one(user_dict)
    
    # Generate token
    token = create_jwt({"sub": user.username})
    
    return {
        "message": "User created successfully",
        "access_token": token,
        "token_type": "bearer"
    }

@app.post("/token")
async def login(user: UserLogin):
    db_user = users_collection.find_one({"username": user.username})
    if not db_user:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    if not verify_password(user.password, db_user["password"]):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    token = create_jwt({"sub": user.username})
    return {"access_token": token, "token_type": "bearer"}

@app.get("/protected")
async def protected_route(token: str = Depends(oauth2_scheme)):
    payload = verify_jwt(token)
    user = users_collection.find_one(
        {"username": payload["sub"]},
        {"password": 0}  # Exclude password from response
    )
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Convert ObjectId to string for JSON serialization
    user["_id"] = str(user["_id"])
    return {"message": f"Hello {user['full_name']}", "user": user}
